[["returns"], ["Close"], ["Close"], ["Close"], ["Close"], {"MACD": "macd_line", "Signal": "signal_line", "Histogram": "histogram"}, ["Close"], ["Close"], {"BB_Upper": "upper_band", "BB_Middle": "sma", "BB_Lower": "lower_band", "BB_Width": "bandwidth"}, ["High"], ["Low"], ["Close"], ["Low"], ["High"], ["Close"], {"Stoch_K": "k", "Stoch_D": "d"}, ["High"], ["Low"], ["High"], ["Low"], ["High"], ["Low"], ["Close"], {"Ichimoku_Tenkan": "tenkan", "Ichimoku_Kijun": "kijun", "Ichimoku_SpanA": "span_a", "Ichimoku_SpanB": "span_b", "Ichimoku_Chikou": "chikou"}, ["Volume"], ["Volume"], {"Volume_Ratio": "volume_ratio", "Volume_Momentum": "volume_momentum"}, ["RSI"], ["ADX"], ["macd_df, bb_df, stoch_df, ichimoku_df, vol_df], axis=1)\n        \n        # Signal generation logic\n        signals = []\n        \n        for i in range(len(self.df)):\n            if i == 0:\n                signals.append(0)\n                continue\n            \n            price = self.df['Close'].iloc[i]\n            \n            # RSI signal\n            rsi = indicators['RSI'].iloc[i]\n            rsi_signal = 1 if rsi < rsi_threshold else (-1 if rsi > (100 - rsi_threshold) else 0)\n            \n            # MACD signal\n            macd = indicators['MACD'].iloc[i]\n            signal_line = indicators['Signal'].iloc[i]\n            macd_signal = 1 if macd > signal_line and macd > 0 else (-1 if macd < signal_line and macd < 0 else 0)\n            \n            # Bollinger Bands signal\n            bb_signal = 0\n            bb_width = indicators['BB_Width'].iloc[i]\n            if bb_width > 0.04:\n                if price > indicators['BB_Upper'].iloc[i-1] and price < indicators['BB_Upper'].iloc[i]:\n                    bb_signal = 1\n                elif price < indicators['BB_Lower'].iloc[i-1] and price > indicators['BB_Lower'].iloc[i]:\n                    bb_signal = -1\n            \n            # ADX trend strength\n            adx = indicators['ADX'].iloc[i]\n            trend_signal = 0\n            if adx > adx_threshold:\n                trend_signal = 1 if indicators['SpanA'].iloc[i] > indicators['SpanB'].iloc[i] else -1\n            \n            # Stochastic signal\n            stoch_signal = 0\n            stoch_k = indicators['Stoch_K'].iloc[i]\n            stoch_d = indicators['Stoch_D'].iloc[i]\n            if stoch_k > stoch_d and stoch_k < 20:\n                stoch_signal = 1\n            elif stoch_k < stoch_d and stoch_k > 80:\n                stoch_signal = -1\n            \n            # Volume signal\n            volume_signal = 1 if indicators['Volume_Momentum'].iloc[i] > 1.5 else 0\n            \n            # Ichimoku confirmation\n            ichimoku_signal = 0\n            chikou = indicators['Ichimoku_Chikou'].iloc[i]\n            if chikou > indicators['Close'].iloc[i-26]:\n                ichimoku_signal = 1\n            elif chikou < indicators['Close'].iloc[i-26]:\n                ichimoku_signal = -1\n            \n            # Combine signals with weighted scoring\n            signal_weights = {\n                'rsi': 1.0, 'macd': 1.2, 'bb': 0.8, 'adx': 1.0,\n                'stoch': 0.8, 'volume': 0.6, 'ichimoku': 1.0\n            }\n            \n            weighted_score = (\n                rsi_signal * signal_weights['rsi'] +\n                macd_signal * signal_weights['macd'] +\n                bb_signal * signal_weights['bb'] +\n                trend_signal * signal_weights['adx'] +\n                stoch_signal * signal_weights['stoch'] +\n                volume_signal * signal_weights['volume'] +\n                ichimoku_signal * signal_weights['ichimoku']\n            )\n            \n            # Only trade if at least 3 indicators confirm\n            final_signal = int(np.sign(weighted_score)) if abs(weighted_score) >= 2 else 0\n            signals.append(final_signal)\n        \n        self.df['Signal'] = signals\n        self.df['Signal_Return'] = self.df['Signal'].shift(-1) * self.df['returns'].fillna(0)\n        \n        return self.df\n\n\nclass PolymarketIntegration:\n    \"\"\"Integration with Polymarket for Bitcoin prediction odds\"\"\"\n    \n    def __init__(self, api_key: str = None):\n        self.api_key = api_key\n        self.base_url = \"https://clob.polymarket.com", "self.headers = {'User-Agent': 'Mozilla/5.0'}\n        if api_key:\n            self.headers['Authorization'] = f'Bearer {api_key}'\n    \n    def get_market_odds(self, market_name: str = \"BTC price will be higher in 24 hours\") -> Dict:\n        \"\"\"Get current market odds from Polymarket\"\"\"\n        try:\n            search_url = \"https://api.polymarket.com/markets", "response = requests.get(search_url, headers=self.headers, params={'search': market_name})\n            response.raise_for_status()\n            markets = response.json()\n            \n            btc_markets = [m for m in markets if 'BTC' in m.get('question', '').upper() or \n                          'BITCOIN' in m.get('question', '').upper()]\n            \n            if btc_markets:\n                market = btc_markets[0]\n                odds = market.get('outcome_prices', {})\n                return {\n                    'market_id': market.get('id'),\n                    'question': market.get('question'),\n                    'yes_price': odds.get('1', 0),\n                    'no_price': odds.get('0', 0),\n                    'decimal_yes': odds.get('1', 0),\n                    'decimal_no': odds.get('0', 0),\n                    'liquidity': market.get('liquidity', 0),\n                    'volume_24h': market.get('volume_24h', 0)\n                }\n            return self._fallback_market_odds()\n        except Exception as e:\n            print(f\"Error fetching Polymarket odds: {e}\")\n            return self._fallback_market_odds()\n    \n    def _fallback_market_odds(self) -> Dict:\n        \"\"\"Generate realistic fallback odds when API fails\"\"\"\n        return {\n            'market_id': 'fallback',\n            'question': 'BTC price will be higher in 24 hours (fallback)',\n            'yes_price': 0.52,\n            'no_price': 0.48,\n            'decimal_yes': 0.52,\n            'decimal_no': 0.48,\n            'liquidity': 100000,\n            'volume_24h': 50000\n        }\n    \n    def get_polymarket_signal(self, signal_type: str = 'long') -> Dict:\n        \"\"\"Determine if market odds favor the signal\"\"\"\n        market_data = self.get_market_odds()\n        \n        if signal_type == 'long':\n            decimal_odds = market_data['decimal_yes']\n            implied_prob = 1 / decimal_odds\n            fair_value = decimal_odds * 0.55\n            recommendation = 'BET_YES' if implied_prob < 0.55 else 'HOLD'\n            edge = 0.55 - implied_prob if implied_prob < 0.55 else 0\n            ev = (fair_value - 1) * 0.55 if recommendation == 'BET_YES' else 0\n        else:\n            decimal_odds = market_data['decimal_no']\n            implied_prob = 1 / decimal_odds\n            fair_value = decimal_odds * 0.55\n            recommendation = 'BET_NO' if implied_prob < 0.55 else 'HOLD'\n            edge = 0.55 - implied_prob if implied_prob < 0.55 else 0\n            ev = (fair_value - 1) * 0.55 if recommendation == 'BET_NO' else 0\n        \n        return {\n            'recommendation': recommendation,\n            'decimal_odds': decimal_odds,\n            'implied_probability': implied_prob,\n            'fair_value': fair_value,\n            'edge': edge,\n            'ev_per_unit': ev\n        }\n\n\nclass PaperTrader:\n    \"\"\"Paper trading simulation with EV calculation\"\"\"\n    \n    def __init__(self, initial_capital: float = 1000.0):\n        self.initial_capital = initial_capital\n        self.capital = initial_capital\n        self.trades = []\n        self.current_date = None\n    \n    def execute_trade(self, df_row: pd.Series, pm_signal: Dict) -> Dict:\n        \"\"\"Execute a trade based on signal and market conditions\"\"\"\n        signal = df_row['Signal']\n        current_price = df_row['Close']\n        date = df_row.name\n        \n        if signal == 1:  # Buy signal\n            position_size = self.capital * 0.9\n            if position_size > 0:\n                shares = position_size / current_price\n                pm_ev = pm_signal['ev_per_unit'] * shares * current_price\n                trade = {\n                    'date': date, 'type': 'BUY', 'price': current_price,\n                    'shares': shares, 'value': position_size,\n                    'signal': 'Momentum_LONG',\n                    'pm_ev': pm_ev, 'polymarket_edge': pm_signal.get('edge', 0)\n                }\n                self.positions.append(trade)\n                self.capital -= position_size\n                self.current_date = date\n                return trade\n        elif signal == -1:  # Sell signal\n            closed_positions = []\n            total_return = 0\n            for pos in self.positions:\n                return_value = pos['shares'] * current_price\n                position_return = (return_value - pos['value']) / pos['value']\n                total_return += position_return\n                close_trade = {\n                    'date': date, 'type': 'SELL', 'price': current_price,\n                    'shares': pos['shares'], 'value': return_value,\n                    'profit': return_value - pos['value'],\n                    'return_pct': position_return * 100,\n                    'signal': 'Momentum_SHORT',\n                    'pm_ev': 0, 'polymarket_edge': 0\n                }\n                closed_positions.append(close_trade)\n                self.capital += return_value\n            self.positions = []\n            self.trades.extend(closed_positions)\n            self.current_date = date\n            return {\n                'date': date, 'type': 'SHORT_CLOSE',\n                'trades': closed_positions,\n                'total_return_pct': total_return * 100,\n                'final_capital': self.capital\n            }\n        return None\n    \n    def calculate_performance_metrics(self) -> Dict:\n        \"\"\"Calculate performance metrics for the backtest\"\"\"\n        if not self.trades:\n            return {\n                'total_trades': 0, 'total_return': 0, 'total_return_pct': 0,\n                'win_rate': 0, 'avg_return': 0, 'max_drawdown': 0,\n                'sharpe_ratio': 0, 'final_capital': self.capital, 'total_ev': 0\n            }\n        \n        buy_returns = [t['return_pct'] for t in self.trades if t['type'] == 'SELL']\n        total_trades = len(buy_returns)\n        win_rate = sum(1 for r in buy_returns if r > 0) / total_trades if total_trades > 0 else 0\n        avg_return = np.mean(buy_returns) if buy_returns else 0\n        \n        # Calculate drawdown\n        equity_curve = [self.initial_capital]\n        for t in self.trades:\n            if t['type'] == 'SELL':\n                equity_curve.append(equity_curve[-1] * (1 + t['return_pct'] / 100))\n            elif t['type'] == 'BUY':\n                equity_curve.append(equity_curve[-1] - t['value'])\n        equity_curve[-1] = self.capital\n        \n        equity_array = np.array(equity_curve)\n        running_max = np.maximum.accumulate(equity_array)\n        drawdown = (equity_array - running_max) / running_max\n        max_drawdown = drawdown.min() * 100\n        \n        # Sharpe ratio\n        sharpe_ratio = np.mean(buy_returns) / np.std(buy_returns) * np.sqrt(252) if len(buy_returns) > 1 else 0\n        \n        total_return = (self.capital - self.initial_capital) / self.initial_capital\n        total_ev = sum(t['pm_ev'] for t in self.trades) if self.trades else 0\n        total_ev += total_return * self.initial_capital\n        \n        return {\n            'total_trades': total_trades,\n            'total_return': self.capital,\n            'total_return_pct': total_return * 100,\n            'win_rate': win_rate,\n            'avg_return': avg_return,\n            'max_drawdown': max_drawdown,\n            'sharpe_ratio': sharpe_ratio,\n            'final_capital': self.capital,\n            'total_pm_ev': sum(t['pm_ev'] for t in self.trades) if self.trades else 0,\n            'ev_from_trades': (self.capital - self.initial_capital),\n            'total_ev': total_ev\n        }\n\n\ndef backtest_strategy(start_date: str = '2025-01-01', end_date: str = '2025-12-31',\n                     initial_capital: float = 1000.0) -> Dict:\n    \"\"\"Run complete backtest of BTC momentum strategy\"\"\"\n    print(f\"Fetching BTC data from {start_date} to {end_date}...", "df = yf.download('BTC-USD', start=start_date, end=end_date)\n    \n    if df.empty:\n        raise ValueError(\"Failed to fetch data\")\n    \n    print(f\"Loaded {len(df)} data points", "signal_gen = BTCSignalGenerator(df)\n    polymarket = PolymarketIntegration()\n    df_with_signals = signal_gen.generate_signals()\n    df_trading = df_with_signals.dropna(subset=['Signal']).copy()\n    \n    print(f", "Trading signals generated: {df_trading['Signal'].sum()} long, {-df_trading['Signal'].sum()} short", "trader = PaperTrader(initial_capital)\n    \n    for idx, row in df_trading.iterrows():\n        if trader.current_date != idx:\n            pm_signal = polymarket.get_polymarket_signal('long')\n            trade = trader.execute_trade(row, pm_signal)\n            if trade:\n                trader.trades.append(trade)\n    \n    metrics = trader.calculate_performance_metrics()\n    return {'df': df_trading, 'trades': trader.trades, 'metrics': metrics}\n\n\ndef main():\n    print(\"=\"*80)\n    print(\"BTC Momentum Strategy Backtest with Polymarket Integration\")\n    print(\"=", 80, "print()\n    \n    try:\n        results = backtest_strategy(start_date='2025-01-01', end_date='2025-12-31',\n                                   initial_capital=1000.0)\n        \n        metrics = results['metrics']\n        print(\"\n\" + \"=\"*80)\n        print(\"BACKTEST RESULTS (2025 Data)\")\n        print(\"=\"*80)\n        print(f", "Initial Capital: $1,000\")\n        print(f", "Final Capital: ${metrics['final_capital']:,.2f}\")\n        print(f", "Total Return: ${metrics['total_return'] - 1000:,.2f} ({metrics['total_return_pct']:.2f}%)\")\n        print(f", "Total Trades: {metrics['total_trades']}\")\n        print(f", "Win Rate: {metrics['win_rate']:.2%}\")\n        print(f", "Average Return per Trade: {metrics['avg_return']:.2f}%\")\n        print(f", "Maximum Drawdown: {metrics['max_drawdown']:.2f}%\")\n        print(f", "Sharpe Ratio: {metrics['sharpe_ratio']:.2f}\")\n        print()\n        print(\"-\"*80)\n        print(\"POLYMARKET EV ANALYSIS\")\n        print(\"-\"*80)\n        print(f", "EV from Trading Signals: ${metrics['ev_from_trades']:,.2f}\")\n        print(f", "EV from Polymarket Integration: ${metrics['total_pm_ev']:,.2f}\")\n        print(f", "Total EV: ${metrics['total_ev']:,.2f}\")\n        print()\n        \n        print(\"-\"*80)\n        print(\"BACKTEST COMPLETE\")\n        print(\"-\"*80)\n        return results\n    except Exception as e:\n        print(f\"Error during backtest: {e}", "import traceback\n        traceback.print_exc()\n        return None\n\n\nif __name__ == '__main__':\n    results = main()"]]