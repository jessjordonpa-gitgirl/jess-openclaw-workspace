[["returns"], ["Close"], ["Close"], ["Close"], ["Close"], {"MACD": "macd_line", "Signal": "signal_line", "Histogram": "histogram"}, ["Close"], ["Close"], {"BB_Upper": "upper_band", "BB_Middle": "sma", "BB_Lower": "lower_band", "BB_Width": "bandwidth"}, ["High"], ["Low"], ["Close"], ["plus_dm < 0] = 0\n        minus_dm[minus_dm > 0] = 0\n\n        tr = np.maximum(high - low,\n                       np.maximum(abs(high - close.shift()),\n                                  abs(low - close.shift())))\n\n        atr = tr.rolling(window=period).mean()\n\n        plus_di = 100 * (plus_dm.rolling(window=period).mean() / atr)\n        minus_di = 100 * (minus_dm.rolling(window=period).mean() / atr)\n\n        dx = 100 * abs(plus_di - minus_di) / (plus_di + minus_di)\n        adx = dx.rolling(window=period).mean()\n\n        return adx\n\n    def calculate_stochastic(self, period_k: int = 14, period_d: int = 3) -> pd.DataFrame:\n        \"", "Calculate Stochastic Oscillator.\"", "\n        low_min = self.df['Low'].rolling(window=period_k).min()\n        high_max = self.df['High'].rolling(window=period_k).max()\n\n        k = 100 * (self.df['Close'] - low_min) / (high_max - low_min)\n        d = k.rolling(window=period_d).mean()\n\n        return pd.DataFrame({\n            'Stoch_K': k,\n            'Stoch_D': d\n        })\n\n    def calculate_ichimoku(self) -> pd.DataFrame:\n        \"", "Calculate Ichimoku Cloud.\"", "\n        tenkan = (self.df['High'].rolling(9).max() + self.df['Low'].rolling(9).min()) / 2\n        kijun = (self.df['High'].rolling(26).max() + self.df['Low'].rolling(26).min()) / 2\n        span_a = ((tenkan + kijun) / 2).shift(26)\n        span_b = ((self.df['High'].rolling(52).max() + self.df['Low'].rolling(52).min()) / 2).shift(26)\n        chikou = self.df['Close'].shift(-26)\n\n        return pd.DataFrame({\n            'Ichimoku_Tenkan': tenkan,\n            'Ichimoku_Kijun': kijun,\n            'Ichimoku_SpanA': span_a,\n            'Ichimoku_SpanB': span_b,\n            'Ichimoku_Chikou': chikou\n        })\n\n    def calculate_volume_metrics(self) -> pd.DataFrame:\n        \"", "Calculate volume-based metrics.\"", "\n        avg_volume = self.df['Volume'].rolling(window=20).mean()\n        volume_ratio = self.df['Volume'] / avg_volume\n        volume_momentum = volume_ratio.diff()\n\n        return pd.DataFrame({\n            'Volume_Ratio': volume_ratio,\n            'Volume_Momentum': volume_momentum\n        })\n\n    def generate_signals(self, rsi_threshold: float = 30.0, adx_threshold: float = 25.0,\n                         bollinger_zone: str = 'middle', stoch_signal: str = 'both') -> pd.DataFrame:\n        \"", "Generate trading signals based on all indicators.\"", "\n\n        # Calculate all indicators\n        self.df['RSI'] = self.calculate_rsi()\n        macd_df = self.calculate_macd()\n        bb_df = self.calculate_bollinger_bands()\n        self.df['ADX'] = self.calculate_adx()\n        stoch_df = self.calculate_stochastic()\n        ichimoku_df = self.calculate_ichimoku()\n        vol_df = self.calculate_volume_metrics()\n\n        # Combine indicators\n        indicators = pd.concat([\n            macd_df, bb_df, stoch_df, ichimoku_df, vol_df\n        ], axis=1)\n\n        # Signal generation logic\n        signals = []\n\n        for i in range(len(self.df)):\n            if i == 0:\n                signals.append(0)\n                continue\n\n            price = self.df['Close'].iloc[i]\n            prev_price = self.df['Close'].iloc[i-1]\n\n            # RSI signal\n            rsi = indicators['RSI'].iloc[i]\n            rsi_signal = 0\n            if rsi < rsi_threshold:\n                rsi_signal = 1\n            elif rsi > (100 - rsi_threshold):\n                rsi_signal = -1\n\n            # MACD signal\n            macd = indicators['MACD'].iloc[i]\n            signal_line = indicators['Signal'].iloc[i]\n            macd_signal = 0\n            if macd > signal_line and macd > 0:\n                macd_signal = 1\n            elif macd < signal_line and macd < 0:\n                macd_signal = -1\n\n            # Bollinger Bands signal\n            bb_signal = 0\n            bb_width = indicators['BB_Width'].iloc[i]\n            if bb_width > 0.04:\n                if price > indicators['BB_Upper'].iloc[i-1] and price < indicators['BB_Upper'].iloc[i]:\n                    bb_signal = 1\n                elif price < indicators['BB_Lower'].iloc[i-1] and price > indicators['BB_Lower'].iloc[i]:\n                    bb_signal = -1\n\n            # ADX trend strength\n            adx = indicators['ADX'].iloc[i]\n            trend_signal = 0\n            if adx > adx_threshold:\n                if indicators['SpanA'].iloc[i] > indicators['SpanB'].iloc[i]:\n                    trend_signal = 1\n                elif indicators['SpanA'].iloc[i] < indicators['SpanB'].iloc[i]:\n                    trend_signal = -1\n\n            # Stochastic signal\n            stoch_signal_val = 0\n            if stoch_signal == 'both':\n                stoch_k = indicators['Stoch_K'].iloc[i]\n                stoch_d = indicators['Stoch_D'].iloc[i]\n                if stoch_k > stoch_d and stoch_k < 20:\n                    stoch_signal_val = 1\n                elif stoch_k < stoch_d and stoch_k > 80:\n                    stoch_signal_val = -1\n            elif stoch_signal == 'long' and indicators['Stoch_K'].iloc[i] > indicators['Stoch_D'].iloc[i]:\n                stoch_signal_val = 1\n            elif stoch_signal == 'short' and indicators['Stoch_K'].iloc[i] < indicators['Stoch_D'].iloc[i]:\n                stoch_signal_val = -1\n\n            # Volume signal\n            volume_signal = 0\n            if indicators['Volume_Momentum'].iloc[i] > 1.5:\n                volume_signal = 1\n\n            # Ichimoku confirmation\n            ichimoku_signal = 0\n            chikou = indicators['Ichimoku_Chikou'].iloc[i]\n            if chikou > indicators['Close'].iloc[i-26]:\n                ichimoku_signal = 1\n            elif chikou < indicators['Close'].iloc[i-26]:\n                ichimoku_signal = -1\n\n            # Combine signals with weighted scoring\n            signal_weights = {\n                'rsi': 1.0,\n                'macd': 1.2,\n                'bb': 0.8,\n                'adx': 1.0,\n                'stoch': 0.8,\n                'volume': 0.6,\n                'ichimoku': 1.0\n            }\n\n            weighted_score = (\n                rsi_signal * signal_weights['rsi'] +\n                macd_signal * signal_weights['macd'] +\n                bb_signal * signal_weights['bb'] +\n                trend_signal * signal_weights['adx'] +\n                stoch_signal_val * signal_weights['stoch'] +\n                volume_signal * signal_weights['volume'] +\n                ichimoku_signal * signal_weights['ichimoku']\n            )\n\n            # Only trade if at least 3 indicators confirm\n            if abs(weighted_score) >= 2:\n                final_signal = int(np.sign(weighted_score))\n            else:\n                final_signal = 0\n\n            signals.append(final_signal)\n\n        self.df['Signal'] = signals\n        self.df['Signal_Return'] = self.df['Signal'].shift(-1) * self.df['returns'].fillna(0)\n\n        return self.df\n\n\nclass PolymarketIntegration:\n    \"", "Integration with Polymarket for Bitcoin prediction odds.\"", "\n\n    def __init__(self, api_key: str = None):\n        self.api_key = api_key\n        self.base_url = \"https://clob.polymarket.com", "self.headers = {'User-Agent': 'Mozilla/5.0'}\n\n        if api_key:\n            self.headers['Authorization'] = f'Bearer {api_key}'\n\n    def get_market_odds(self, market_name: str = \"BTC price will be higher in 24 hours\") -> Dict:\n        \"", "Get current market odds from Polymarket.\"", "\n\n        try:\n            search_url = \"https://api.polymarket.com/markets", "params = {'search': market_name}\n\n            response = requests.get(search_url, headers=self.headers, params=params)\n            response.raise_for_status()\n\n            markets = response.json()\n\n            # Filter for BTC-related markets\n            btc_markets = [m for m in markets if 'BTC' in m.get('question', '').upper() or\n                          'BITCOIN' in m.get('question', '').upper()]\n\n            if btc_markets:\n                market = btc_markets[0]\n                odds = market.get('outcome_prices', {})\n\n                return {\n                    'market_id': market.get('id'),\n                    'question': market.get('question'),\n                    'yes_price': odds.get('1', 0),\n                    'no_price': odds.get('0', 0),\n                    'liquidity': market.get('liquidity', 0),\n                    'volume_24h': market.get('volume_24h', 0),\n                    'total_traded': market.get('total_traded', 0),\n                    'open_interest': market.get('open_interest', 0),\n                    'decimal_yes': odds.get('1', 0),\n                    'decimal_no': odds.get('0', 0)\n                }\n            else:\n                return self._fallback_market_odds()\n\n        except Exception as e:\n            print(f\"Error fetching Polymarket odds: {e}\")\n            return self._fallback_market_odds()\n\n    def _fallback_market_odds(self) -> Dict:\n        \"", "Generate realistic fallback odds when API fails.\"", "\n        return {\n            'market_id': 'fallback',\n            'question': 'BTC price will be higher in 24 hours (fallback)',\n            'yes_price': 0.52,\n            'no_price': 0.48,\n            'decimal_yes': 0.52,\n            'decimal_no': 0.48,\n            'liquidity': 100000,\n            'volume_24h': 50000,\n            'total_traded': 200000,\n            'open_interest': 100000\n        }\n\n    def get_polymarket_signal(self, current_price: float, signal_type: str = 'long') -> Dict:\n        \"", "Determine if market odds favor the signal.\"", "\n\n        market_data = self.get_market_odds()\n\n        if signal_type == 'long':\n            decimal_odds = market_data['decimal_yes']\n            implied_prob = 1 / decimal_odds\n            fair_value = decimal_odds * 0.55\n\n            if implied_prob > 0.55:\n                recommendation = 'HOLD'\n                edge = 0\n                ev = 0\n            else:\n                recommendation = 'BET_YES'\n                edge = 0.55 - implied_prob\n                ev = (fair_value - 1) * 0.55\n\n        else:\n            decimal_odds = market_data['decimal_no']\n            implied_prob = 1 / decimal_odds\n            fair_value = decimal_odds * 0.55\n\n            if implied_prob > 0.55:\n                recommendation = 'HOLD'\n                edge = 0\n                ev = 0\n            else:\n                recommendation = 'BET_NO'\n                edge = 0.55 - implied_prob\n                ev = (fair_value - 1) * 0.55\n\n        return {\n            'market_data': market_data,\n            'signal_type': signal_type,\n            'recommendation': recommendation,\n            'decimal_odds': decimal_odds,\n            'implied_probability': implied_prob,\n            'fair_value': fair_value,\n            'edge': edge,\n            'ev_per_unit': ev,\n            'current_price': current_price\n        }\n\n\nclass PaperTrader:\n    \"", "Paper trading simulation with EV calculation.\"", "\n\n    def __init__(self, initial_capital: float = 1000.0):\n        self.initial_capital = initial_capital\n        self.capital = initial_capital\n        self.positions = []\n        self.trades = []\n        self.current_date = None\n\n    def execute_trade(self, df_row: pd.Series, polymarket_signal: Dict) -> Dict:\n        \"", "Execute a trade based on signal and market conditions.\"", "\n\n        signal = df_row['Signal']\n        current_price = df_row['Close']\n        date = df_row.name\n\n        if signal == 1:  # Buy signal\n            position_size = self.capital * 0.9\n            if position_size > 0:\n                shares = position_size / current_price\n\n                pm_ev = polymarket_signal['ev_per_unit'] * shares * current_price\n\n                trade = {\n                    'date': date,\n                    'type': 'BUY',\n                    'price': current_price,\n                    'shares': shares,\n                    'value': position_size,\n                    'signal': 'Momentum_LONG',\n                    'pm_signal': polymarket_signal.get('recommendation', 'N/A'),\n                    'pm_ev': pm_ev,\n                    'polymarket_edge': polymarket_signal.get('edge', 0)\n                }\n\n                self.positions.append(trade)\n                self.capital -= position_size\n                self.current_date = date\n                return trade\n\n        elif signal == -1:  # Sell signal\n            closed_positions = []\n            total_return = 0\n\n            for pos in self.positions:\n                return_value = pos['shares'] * current_price\n                position_return = (return_value - pos['value']) / pos['value']\n                total_return += position_return\n\n                close_trade = {\n                    'date': date,\n                    'type': 'SELL',\n                    'price': current_price,\n                    'shares': pos['shares'],\n                    'value': return_value,\n                    'profit': return_value - pos['value'],\n                    'return_pct': position_return * 100,\n                    'signal': 'Momentum_SHORT',\n                    'pm_signal': polymarket_signal.get('recommendation', 'N/A'),\n                    'pm_ev': 0,\n                    'polymarket_edge': 0\n                }\n\n                closed_positions.append(close_trade)\n                self.capital += return_value\n\n            self.positions = []\n            self.trades.extend(closed_positions)\n            self.current_date = date\n\n            avg_pm_ev = sum(p['pm_ev'] for p in closed_positions) / len(closed_positions)\n            ev_from_trades = total_return * self.initial_capital\n\n            return {\n                'date': date,\n                'type': 'SHORT_CLOSE',\n                'trades': closed_positions,\n                'total_return': total_return,\n                'total_return_pct': total_return * 100,\n                'final_capital': self.capital,\n                'total_pm_ev': avg_pm_ev,\n                'ev_from_trades': ev_from_trades\n            }\n\n        return None\n\n    def calculate_performance_metrics(self) -> Dict:\n        \"", "Calculate performance metrics for the backtest.\"", "\n\n        if not self.trades:\n            return {\n                'total_trades': 0,\n                'total_return': 0,\n                'total_return_pct': 0,\n                'win_rate': 0,\n                'avg_return': 0,\n                'max_drawdown': 0,\n                'sharpe_ratio': 0,\n                'final_capital': self.capital,\n                'total_ev': 0\n            }\n\n        # Calculate returns from trades\n        buy_returns = [t['return_pct'] for t in self.trades if t['type'] == 'SELL']\n        total_trades = len(buy_returns)\n        win_rate = sum(1 for r in buy_returns if r > 0) / total_trades if total_trades > 0 else 0\n        avg_return = np.mean(buy_returns) if buy_returns else 0\n\n        # Calculate EV from Polymarket\n        total_pm_ev = sum(t['pm_ev'] for t in self.trades) if self.trades else 0\n\n        # Calculate equity curve\n        equity_curve = [self.initial_capital]\n        for t in self.trades:\n            if t['type'] == 'SELL':\n                equity_curve.append(equity_curve[-1] * (1 + t['return_pct'] / 100))\n            elif t['type'] == 'BUY':\n                equity_curve.append(equity_curve[-1] - t['value'])\n\n        equity_curve[-1] = self.capital\n\n        # Calculate drawdown\n        equity_array = np.array(equity_curve)\n        running_max = np.maximum.accumulate(equity_array)\n        drawdown = (equity_array - running_max) / running_max\n        max_drawdown = drawdown.min() * 100\n\n        # Calculate Sharpe ratio\n        if len(buy_returns) > 1:\n            sharpe_ratio = np.mean(buy_returns) / np.std(buy_returns) * np.sqrt(252)\n        else:\n            sharpe_ratio = 0\n\n        # Calculate total return\n        total_return = (self.capital - self.initial_capital) / self.initial_capital\n        total_return_pct = total_return * 100\n\n        # Calculate total EV\n        total_ev = sum(t['pm_ev'] for t in self.trades) if self.trades else 0\n        total_ev += total_return * self.initial_capital\n\n        return {\n            'total_trades': total_trades,\n            'total_return': self.capital,\n            'total_return_pct': total_return_pct,\n            'win_rate': win_rate,\n            'avg_return': avg_return,\n            'max_drawdown': max_drawdown,\n            'sharpe_ratio': sharpe_ratio,\n            'final_capital': self.capital,\n            'total_pm_ev': total_pm_ev,\n            'ev_from_trades': (self.capital - self.initial_capital),\n            'total_ev': total_ev\n        }\n\n\ndef backtest_strategy(start_date: str = '2025-01-01', end_date: str = '2025-12-31',\n                     initial_capital: float = 1000.0) -> Dict:\n    \"", "Run complete backtest of BTC momentum strategy.\"", "\n\n    print(f\"Fetching BTC data from {start_date} to {end_date}...", "df = yf.download('BTC-USD', start=start_date, end=end_date)\n\n    if df.empty:\n        raise ValueError(\"Failed to fetch data\")\n\n    print(f\"Loaded {len(df)} data points\")\n\n    # Initialize components\n    signal_gen = BTCSignalGenerator(df)\n    polymarket = PolymarketIntegration()\n\n    # Generate signals\n    print(\"Generating trading signals...", "df_with_signals = signal_gen.generate_signals()\n\n    # Filter for trading days\n    df_trading = df_with_signals.dropna(subset=['Signal']).copy()\n\n    print(f", "Trading signals generated: {df_trading['Signal'].sum()} long, {-df_trading['Signal'].sum()} short\")\n\n    # Run paper trading\n    print(\"Running paper trading simulation...", "trader = PaperTrader(initial_capital)\n\n    # Process each trading signal\n    for idx, row in df_trading.iterrows():\n        if trader.current_date != idx:\n            # Get Polymarket signal\n            pm_signal = polymarket.get_polymarket_signal(row['Close'], 'long')\n\n            # Execute trade\n            trade = trader.execute_trade(row, pm_signal)\n            if trade:\n                trader.trades.append(trade)\n\n    # Calculate performance\n    metrics = trader.calculate_performance_metrics()\n\n    return {\n        'df': df_trading,\n        'trades': trader.trades,\n        'metrics': metrics,\n        'signal_generator': signal_gen,\n        'polymarket': polymarket\n    }\n\n\ndef plot_results(df: pd.DataFrame, metrics: Dict):\n    \"", "Plot backtest results.\"", "\n    fig, axes = plt.subplots(3, 1, figsize=(14, 12))\n\n    # Price and signals\n    ax1 = axes[0]\n    ax1.plot(df.index, df['Close'], label='BTC Price', color='blue', alpha=0.7)\n    ax1.axhline(y=df['Close'].mean(), color='gray', linestyle='--', alpha=0.5, label='Moving Avg')\n\n    buy_signals = df[df['Signal'] == 1]\n    sell_signals = df[df['Signal'] == -1]\n\n    ax1.scatter(buy_signals.index, buy_signals['Close'], color='green', marker='^',\n                s=100, label='Buy Signal', alpha=0.7)\n    ax1.scatter(sell_signals.index, sell_signals['Close'], color='red', marker='v',\n                s=100, label='Sell Signal', alpha=0.7)\n\n    ax1.set_title('BTC Price and Trading Signals', fontsize=14, fontweight='bold')\n    ax1.set_ylabel('Price (USD)')\n    ax1.legend()\n    ax1.grid(True, alpha=0.3)\n\n    # RSI indicator\n    ax2 = axes[1]\n    ax2.plot(df.index, df['RSI'], color='purple', label='RSI (14)')\n    ax2.axhline(y=70, color='red', linestyle='--', alpha=0.5, label='Overbought')\n    ax2.axhline(y=30, color='green', linestyle='--', alpha=0.5, label='Oversold')\n\n    if 'Signal' in df.columns:\n        ax2.scatter(buy_signals.index, buy_signals['RSI'], color='green', marker='^', s=50, alpha=0.7)\n        ax2.scatter(sell_signals.index, sell_signals['RSI'], color='red', marker='v', s=50, alpha=0.7)\n\n    ax2.set_title('RSI Indicator', fontsize=14, fontweight='bold')\n    ax2.set_ylabel('RSI')\n    ax2.legend()\n    ax2.grid(True, alpha=0.3)\n\n    # ADX indicator\n    ax3 = axes[2]\n    ax3.plot(df.index, df['ADX'], color='orange', label='ADX (14)')\n    ax3.axhline(y=25, color='gray', linestyle='--', alpha=0.5, label='Trend Threshold')\n\n    if 'Signal' in df.columns:\n        ax3.scatter(buy_signals.index, buy_signals['ADX'], color='green', marker='^', s=50, alpha=0.7)\n        ax3.scatter(sell_signals.index, sell_signals['ADX'], color='red', marker='v', s=50, alpha=0.7)\n\n    ax3.set_title('ADX Trend Strength', fontsize=14, fontweight='bold')\n    ax3.set_ylabel('ADX')\n    ax3.legend()\n    ax3.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.savefig('workspace/btc_backtest.png', dpi=150, bbox_inches='tight')\n    print(\"Backtest chart saved to workspace/btc_backtest.png\")\n\n\ndef main():\n    \"", "Main execution function.\"", "\n    print(\"=\" * 80)\n    print(\"BTC Momentum Strategy Backtest with Polymarket Integration\")\n    print(\"=", 80, "print()\n\n    try:\n        # Run backtest\n        results = backtest_strategy(\n            start_date='2025-01-01',\n            end_date='2025-12-31',\n            initial_capital=1000.0\n        )\n\n        # Print metrics\n        metrics = results['metrics']\n\n        print(\"\n\" + \"=\" * 80)\n        print(\"BACKTEST RESULTS (2025 Data)\")\n        print(\"=\" * 80)\n        print(f", "Initial Capital: $1,000\")\n        print(f", "Final Capital: ${metrics['final_capital']:,.2f}\")\n        print(f", "Total Return: ${metrics['total_return'] - 1000:,.2f} ({metrics['total_return_pct']:.2f}%)\")\n        print(f", "Total Trades: {metrics['total_trades']}\")\n        print(f", "Win Rate: {metrics['win_rate']:.2%}\")\n        print(f", "Average Return per Trade: {metrics['avg_return']:.2f}%\")\n        print(f", "Maximum Drawdown: {metrics['max_drawdown']:.2f}%\")\n        print(f", "Sharpe Ratio: {metrics['sharpe_ratio']:.2f}\")\n        print()\n\n        print(\"-\" * 80)\n        print(\"POLYMARKET EV ANALYSIS\")\n        print(\"-\" * 80)\n        print(f", "EV from Trading Signals: ${metrics['ev_from_trades']:,.2f}\")\n        print(f", "EV from Polymarket Integration: ${metrics['total_pm_ev']:,.2f}\")\n        print(f", "Total EV: ${metrics['total_ev']:,.2f}", "print()\n\n        # Show sample Polymarket signal\n        pm = results['polymarket']\n        sample_signal = pm.get_market_odds()\n        print(\"-\" * 80)\n        print(\"CURRENT POLYMARKET MARKET ODDS\")\n        print(\"-\" * 80)\n        print(f", "Market Question: {sample_signal['question']}\")\n        print(f", "Yes Price: {sample_signal['yes_price']:.2f} (Implied Prob: {sample_signal['decimal_yes']:.2%})\")\n        print(f", "No Price: {sample_signal['no_price']:.2f} (Implied Prob: {sample_signal['decimal_no']:.2%})\")\n        print(f", "Liquidity: ${sample_signal['liquidity']:,.0f}\")\n        print(f", 24, "h Volume: ${sample_signal['volume_24h']:,.0f}\")\n        print()\n\n        # Plot results\n        print(\"Generating charts...", "plot_results(results['df'], metrics)\n\n        print(\"\n\" + \"=\" * 80)\n        print(\"BACKTEST COMPLETE\")\n        print(\"=\" * 80)\n\n        return results\n\n    except Exception as e:\n        print(f\"\nError during backtest: {e}", "import traceback\n        traceback.print_exc()\n        return None\n\n\nif __name__ == '__main__':\n    results = main()"]]